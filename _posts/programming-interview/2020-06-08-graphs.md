---
title: A summary of Graphs
published: true
tags:
  - Programming Interview
  - Python
---

<!--more-->

## Graphs

<div class="card mb-3">
    <img class="card-img-top" src="{{ site.baseurl }}/assets/img/2020-06-07-graphs/graph-representation.svg"/>
    <div class="card-body bg-light">
        <div class="card-text">
            Graph
        </div>
    </div>
</div>

### Graph can be represented in 3 ways:

- ```python
  edge_list = [("A", "B"), ("A", "C"), ("A", "D"), ("C", "D"),
  ("E", "F"), ("G", "H"), ("G", "I"), ("H", "I") ]
  ```
- ```python
  adjacency_matrix = [
    [0, 1, 1, 1, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 1, 0, 0, 0, 0, 0],
    [1, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 1, 0]]
  ```
- ```python
  adjacency_list = {'A': ['B', 'C'], 'B': ['A'], 'C': ['A', 'D'], 'D': ['A', 'C'],
  'E': ['F'], 'F': ['E'], 'G': ['H', 'I'], 'H': ['G', 'I'], 'I': ['G', 'H']}
  ```

### Graph API

We use integers between `0` and `V â€“ 1` to denote vertices. A graph is presented as adjacency list. And index `i` stores a `list` that includes all neighbors of that index `i`.

#### Read graph from input

- Example `input.txt`

```
13 13
0 5
4 3
0 1
9 12
6 4
5 4
0 2
11 12
9 10
0 6
7 8
9 11
5 3
```

The the first item:`13` at the first line denotes the number of vertices $$ V $$ and the second item:`13` denotes the number of edges $$ E $$.
Below is a simple API that reads `input.txt` and returns a `graph: List[List[int]]`.

```python
# python build_graph.py < input.txt
import sys
if __name__ == '__main__':
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    n, m = data[0:2]
    data = data[2:]
    graph = [[] for _ in range(n)]
    for i in range(len(data[::2])):
      v, w = data[i * 2: i * 2 + 2]
      graph[v].append(w)
      graph[w].append(v)
    print(graph)
```

#### DFS

```python
def DFS(adjacency_list):
  visited = {k: False for k in adjacency_list.keys()}
  for k in adjacency_list.keys():
    explore(adjacency_list, visited, k)
  return visited

def explore(adjacency_list, visited, vertex):
  visited[vertex] = True
  for key in adjacency_list[vertex]:
    if not visited[key]:
      explore(adjacency_list, visited, key)

```

#### Connected Components

```python
def DFS(adjacency_list):
  visited = {k: False for k in adjacency_list.keys()}
  cc_counter = 1
  connected_component_nums = {k: -1 for k in adjacency_list.keys()}
  for k in adjacency_list.keys():
    if not visited[k]:
      explore(adjacency_list, visited, k, connected_component_nums, cc_counter)
      cc_counter += 1
  return connected_component_nums

def explore(adjacency_list, visited, vertex, connected_component_nums, cc_counter):
  visited[vertex] = True
  connected_component_nums[vertex] = cc_counter
  for key in adjacency_list[vertex]:
    if not visited[key]:
      explore(adjacency_list, visited, key, connected_component_nums, cc_counter)

```

#### DAG

- DAG Definitions
  - Directed acyclic graph is a graph that has **no cycles**
  - **Source** is a vertex with no incoming edges
  - **Sink** is a vertex with no outgoing edges

#### BFS

Put unvisited vertices on a `Queue`.

```python
def BFS(graph: List[List[str]], source:int) -> List[int]:
    queue = collections.deque()
    visited = [False] * len(graph)
    edgeTo = [-1] * len(graph)
    queue.append(source)
    visited[source] = True
    while len(queue):
        v = queue.popleft()
        for w in graph[v]:
            if not visited[w]:
                queue.append(w)
                visited[w] = True
                edgeTo[w] = v
    return edgeTo

if __name__ == '__main__':
    # input.txt
    # 6 8
    # 0 5
    # 2 4
    # 2 3
    # 1 2
    # 0 1
    # 3 4
    # 3 5
    # 0 2
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    n, m = data[0:2]
    data = data[2:]
    graph = [[] for _ in range(n)]
    for i in range(len(data[::2])):
        v, w = data[i * 2: i * 2 + 2]
        graph[v].append(w)
        graph[w].append(v)
    print("Graph: ", graph)
    print(BFS(graph, 0))
```
