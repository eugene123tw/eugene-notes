---
title: A summary of Graphs
published: true
tags:
  - Programming Interview
  - Python
---

<!--more-->

## Graphs

<div class="card mb-3">
    <img class="card-img-top" src="{{ site.baseurl }}/assets/img/2020-06-07-graphs/graph-representation.svg"/>
    <div class="card-body bg-light">
        <div class="card-text">
            Graph
        </div>
    </div>
</div>

### Graph can be represented in 3 ways:

- ```python
  edge_list = [(0, 1), (0, 2), (0, 3), (2, 3), (4, 5), (6, 7), (6, 8), (7, 8) ]
  ```
- ```python
  adjacency_matrix = [
    [0, 1, 1, 1, 0, 0, 0, 0, 0],
    [1, 0, 0, 0, 0, 0, 0, 0, 0],
    [1, 0, 0, 1, 0, 0, 0, 0, 0],
    [1, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 0, 0, 1, 0]]
  ```
- ```python
  adjacency_list = [[1,2,3],[0],[0, 3],[0, 2],[5],[4],[7,8],[6,8],[7]]
  ```

### Graph API

We use integers between `0` and `V â€“ 1` to denote vertices. A graph is presented as adjacency list. And index `i` stores a `list` that includes all neighbors of that index `i`.

#### Read graph from input

- Example `input.txt`

```
13 13
0 5
4 3
0 1
9 12
6 4
5 4
0 2
11 12
9 10
0 6
7 8
9 11
5 3
```

The the first item:`13` at the first line denotes the number of vertices $$ V $$ and the second item:`13` denotes the number of edges $$ E $$.
Below is a simple API that reads `input.txt` and returns a `graph: List[List[int]]`.

```python
# python build_graph.py < input.txt
import sys
if __name__ == '__main__':
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    n, m = data[0:2]
    data = data[2:]
    graph = [[] for _ in range(n)]
    for i in range(len(data[::2])):
      v, w = data[i * 2: i * 2 + 2]
      graph[v].append(w)
      graph[w].append(v)
    print(graph)
```

#### Depth First Search - DFS

Put unvisited vertices on a `Stack`

```python
def DFS(graph: List[List[str]]):
  visited = [False] * len(graph)
  def explore(graph: List[List[str]], v: int):
    visited[v] = True
    # pre-visit(v)
    for w in graph[v]:
      if not visited[w]:
        explore(graph, w)
    # post-visit(v)

  for i in range(len(graph)):
    if not visited[i]:
      explore(graph, i)
  print(visited)
```

#### Connected Components

```python
def DFS(graph: List[List[str]]):
  visited = [False] * len(graph)
  cc_list = [0] * len(graph)  # connected components
  cc = 0
  def explore(graph: List[List[str]], v: int, cc):
    visited[v] = True
    cc_list[v] = cc
    for w in graph[v]:
      if not visited[w]:
        explore(graph, w, cc)
  for i in range(len(graph)):
    if not visited[i]:
      cc += 1
      explore(graph, i, cc)
  print(cc_list)
```

#### Directed Acyclic Graph - DAG

- DAG Definitions
  - Directed acyclic graph is a graph that has **no cycles**
  - **Source** is a vertex with no incoming edges
  - **Sink** is a vertex with no outgoing edges

#### Breadth First Search - BFS

Put unvisited vertices on a `Queue`.

```python
def BFS(graph: List[List[str]], source:int) -> List[int]:
    queue = collections.deque()
    visited = [False] * len(graph)
    edgeTo = [-1] * len(graph)
    queue.append(source)
    visited[source] = True
    while len(queue):
        v = queue.popleft()
        for w in graph[v]:
            if not visited[w]:
                queue.append(w)
                visited[w] = True
                edgeTo[w] = v
    return edgeTo

if __name__ == '__main__':
    # input.txt
    # 6 8
    # 0 5
    # 2 4
    # 2 3
    # 1 2
    # 0 1
    # 3 4
    # 3 5
    # 0 2
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    n, m = data[0:2]
    data = data[2:]
    graph = [[] for _ in range(n)]
    for i in range(len(data[::2])):
        v, w = data[i * 2: i * 2 + 2]
        graph[v].append(w)
        graph[w].append(v)
    print("Graph: ", graph)
    print(BFS(graph, 0))
```
