---
title: A summary of Arrays
published: true
tags:
  - Arrays
  - Programming Interview
  - Python
---

# Arrays

- Objectives:
  - Find a way to use the array itself to **reduce space** complexity to $$ O(1) $$
  - Filling ad array from the front is slow, so see it's possible to **write values from the back**
  - Instead deleting an entry, consider overwriting it
  - Be comfortable with writing code that operates on **subarrays**
  - Be careful with indexing, it's easy to make **off-by-1** errors

<!--more-->

### Knowledge

#### Difference between `copy.copy` and `copy.deepcopy`.

[Check this post](https://stackoverflow.com/a/17246744/5978883)

#### [Binary Search for sorted lists](https://docs.python.org/3/library/bisect.html)

```python
>>> A = [1, 3, 4, 4, 4, 6, 7]
>>> bisect.bisect(a=A, x=4)  # returns the index + 1 for insert of the rightmost `x` from `a`
5
>>> bisect.bisect_right(a=A, x=4, lo=0, hi=4)  # lo: sublist lower index, hi: sublist higher index
4
```

## 2.1 The dutch national flag problem

Suppose 0:red, 1:white, 2:blue represents the color in array `A=[1, 0, 0, 1, 1, 2, 2, 0, 2]`, and the pivot index is 3 (`A[3]=1`). Write a program that all elements less than `A[i]` (the “pivot”) appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. In that sense, `A = [0, 0, 0, 1, 1, 1, 2, 2, 2]`

<div class="embed-responsive embed-responsive-21by9" style="height: 170px;">
  <iframe class="embed-responsive-item" src="{{ site.baseurl }}/assets/demo/dutch_flag.html"></iframe>
</div>

### Method 1

I create a cache `counts` to save the number occurrences of `[0, 1 ,2]`, respectively. Since it is already sorted, we only need to change the array according to `counts`.

```python
def dutch_flag_partition(pivot_index: int, A: List[int]) -> None:
    counts = [0, 0, 0]
    for i in A:
        counts[i] += 1

    begin = 0
    for idx, count in enumerate(counts):
        end = count + begin
        A[begin: end] = [idx] * count
        begin = end
```

## 2. Rotate Matrix

### WIP

## 18. Compute the spiral orderig of a 2D array

### Method 1

Although my workable solution lacks structure and is hard to understand at first glance, the concept I adopt is actually trivial. I choose to create 2 variables to control the shifting of the x-axis and y-axis and move left/right/up/down according to the current position and change shifting variables whenever it reaches top/right/bottom/left boundary.

We could observe that the program should move right until it reached the top-right corner, and keep moving downwards till it reached the bottom-right, then move left to the bottom-left corner, and finally going upwards until it reaches the end of the outmost spiral, then it has to step in the inner spiral, changing the boundaries and repeat again.

<div class="embed-responsive embed-responsive-21by9" style="height: 320px;">
  <iframe class="embed-responsive-item" src="{{ site.baseurl }}/assets/demo/spiral.html"></iframe>
</div>

```python
def matrix_in_spiral_order(square_matrix: List[List[int]]) -> List[int]:
    if len(matrix) == 0:
      return []
    left_bound, right_bound = 0, len(matrix[0]) - 1
    bottom_bound, top_bound = 0, len(matrix) - 1
    if (top_bound == bottom_bound) | (left_bound == right_bound):
      return [value for row in matrix for value in row]
    matrix_size = (right_bound + 1) * (top_bound + 1)
    count = 0
    row_shift, col_shift = 0, 0
    row, col = 0, 0
    flatten = []
    start_corner = [0, 0]
    while count < matrix_size:
      flatten.append(matrix[row][col])
      if col == right_bound:
          row_shift = 1
      elif col == left_bound:
          row_shift = -1
      if row == top_bound:
          col_shift = -1
      elif row == bottom_bound:
          col_shift = 1
      if ((row + row_shift) < bottom_bound) | ((row + row_shift) > top_bound):
          row_shift = 0
      if ((col + col_shift) < left_bound) | ((col + col_shift) > right_bound):
          col_shift = 0
      if ((row + row_shift) == start_corner[0]) and ((col + col_shift) == start_corner[1]):
          start_corner[0] += 1
          start_corner[1] += 1
          row_shift = 0
          col_shift = 1
          left_bound += 1
          right_bound -= 1
          bottom_bound += 1
          top_bound -= 1
      row += row_shift
      col += col_shift
      count += 1
    return flatten
```

### Method 2

I discovered a more elegant way to solve the problem from element python interview.

```python
def matrix_in_spiral_order(square_matrix: List[List[int]]) -> List[int]:
    flatten = []
    for outer in range(len(square_matrix) // 2):
        N = len(square_matrix) - outer
        for i in range(outer, N - 1):
            flatten.append(square_matrix[outer][i])
        for i in range(outer, N - 1):
            flatten.append(square_matrix[i][-1 - outer])
        for i in range(N - 1, outer, -1):
            flatten.append(square_matrix[-1 - outer][i])
        for i in range(N - 1, outer, -1):
            flatten.append(square_matrix[i][outer])
    if len(square_matrix) % 2:
        center = len(square_matrix) // 2
        flatten.append(square_matrix[center][center])
    return flatten
```
