---
title: A summary of Arrays
published: true
tags:
  - Arrays
  - Programming Interview
  - Python
---

# Arrays

- Objectives:
  - Find a way to use the array itself to **reduce space** complexity to $$ O(1) $$
  - Filling ad array from the front is slow, so see it's possible to **write values from the back**
  - Instead deleting an entry, consider overwriting it
  - Be comfortable with writing code that operates on **subarrays**
  - Be careful with indexing, it's easy to make **off-by-1** errors

<!--more-->

### Knowledge

#### Difference between `copy.copy` and `copy.deepcopy`.

[Check this post](https://stackoverflow.com/a/17246744/5978883)

#### [Binary Search for sorted lists](https://docs.python.org/3/library/bisect.html)

```python
>>> A = [1, 3, 4, 4, 4, 6, 7]
>>> bisect.bisect(a=A, x=4)  # returns the index + 1 for insert of the rightmost `x` from `a`
5
>>> bisect.bisect_right(a=A, x=4, lo=0, hi=4)  # lo: sublist lower index, hi: sublist higher index
4
```

## 2.1 The dutch national flag problem

Suppose 0:red, 1:white, 2:blue represents the color in array `A=[0, 1, 2, 0 ,2 ,1, 1]`, and the pivot index is 3 (`A[3]=`). Write a program that all elements less than `A[i]` (the “pivot”) appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. In that sense, `A = [0, 0, 1, 1, 1, 2, 2]`

<div class="embed-responsive embed-responsive-21by9" style="height: 170px;">
  <iframe class="embed-responsive-item" src="{{ site.baseurl }}/assets/demo/dutch_flag.html"></iframe>
</div>

### Method 1

I create a cache `counts` to save the number occurrences of `[0, 1 ,2]`, respectively. Since it is already sorted, we only have change the array according to `counts`.

```python
def dutch_flag_partition(pivot_index: int, A: List[int]) -> None:
    counts = [0, 0, 0]
    for i in A:
        counts[i] += 1

    begin = 0
    for idx, count in enumerate(counts):
        end = count + begin
        A[begin: end] = [idx] * count
        begin = end
```
