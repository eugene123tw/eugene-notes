---
title: A summary of Arrays
published: true
tags:
  - Arrays
  - Programming Interview
  - Python
---

# Arrays

- Objectives:
  - Find a way to use the array itself to **reduce space** complexity to $$ O(1) $$
  - Filling ad array from the front is slow, so see it's possible to **write values from the back**
  - Instead deleting an entry, consider overwriting it
  - Be comfortable with writing code that operates on **subarrays**
  - Be careful with indexing, it's easy to make **off-by-1** errors

<!--more-->

### Knowledge

#### Difference between `copy.copy` and `copy.deepcopy`.

[Check this post](https://stackoverflow.com/a/17246744/5978883)

#### [Binary Search for sorted lists](https://docs.python.org/3/library/bisect.html)

```python
>>> A = [1, 3, 4, 4, 4, 6, 7]
>>> bisect.bisect(a=A, x=4)  # returns the index + 1 for insert of the rightmost `x` from `a`
5
>>> bisect.bisect_right(a=A, x=4, lo=0, hi=4)  # lo: sublist lower index, hi: sublist higher index
4
```

## 2.1 The dutch national flag problem

Suppose 0:red, 1:white, 2:blue represents the color in array `A=[1, 0, 0, 1, 1, 2, 2, 0, 2]`, and the pivot index is 3 (`A[3]=1`). Write a program that all elements less than `A[i]` (the “pivot”) appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. In that sense, `A = [0, 0, 0, 1, 1, 1, 2, 2, 2]`

<div class="embed-responsive embed-responsive-21by9" style="height: 170px;">
  <iframe class="embed-responsive-item" src="{{ site.baseurl }}/assets/demo/dutch_flag.html"></iframe>
</div>

### Method 1

I create a cache `counts` to save the number occurrences of `[0, 1 ,2]`, respectively. Since it is already sorted, we only need to change the array according to `counts`.

```python
def dutch_flag_partition(pivot_index: int, A: List[int]) -> None:
    counts = [0, 0, 0]
    for i in A:
        counts[i] += 1

    begin = 0
    for idx, count in enumerate(counts):
        end = count + begin
        A[begin: end] = [idx] * count
        begin = end
```

## 2. Rotate Matrix

### WIP

## 18. Compute the spiral orderig of a 2D array

Although my workable solution lacks structure and is hard to understand at first glance, the concept I adopt is actually trivial. I choose to create 2 variables to control the shifting of the x-axis and y-axis and move left/right/up/down according to the current position.

We could observe that the program should move right until it reached the top-right corner, and keep moving downwards till it reached the bottom-right, then move left to the bottom-left corner, and finally going upwards until we traveled all outer spiral. Once we traveled the outer spiral, we have to step in the inner spiral and also remember to change the boundary.

<div class="embed-responsive embed-responsive-21by9" style="height: 320px;">
  <iframe class="embed-responsive-item" src="{{ site.baseurl }}/assets/demo/spiral.html"></iframe>
</div>

```python
def matrix_in_spiral_order(square_matrix: List[List[int]]) -> List[int]:
    matrix_size = len(square_matrix) ** 2
    left_bound, right_bound = 0, len(square_matrix) - 1
    count = 0

    # defines shift variables to control index shifting
    row_shift, col_shift = 0, 0

    # defines and initialise starting row and column
    row, col = 0, 0

    # storing the spiralled value in 1D array
    flatten = []

    while count < matrix_size:
        if col == right_bound:
            # shift +1 along y-axis when reached the maximum width
            row_shift = 1
        elif col == left_bound:
            # shift -1 along y-axis when reached the minimum width
            row_shift = -1

        if row == right_bound:
            # shift -1 along x-axis when reached the maximum height
            col_shift = -1
        elif row == left_bound:
            # shift +1 along x-axis when reached the minimum height
            col_shift = 1

        flatten.append(square_matrix[row][col])

        if ((row + row_shift) < left_bound) | ((row + row_shift) > right_bound):
            row_shift = 0

        if ((col + col_shift) < left_bound) | ((col + col_shift) > right_bound):
            col_shift = 0

        if ((row + row_shift) == (col + col_shift)) and ((row + row_shift) != right_bound):
            # move into inner spiral: change boundary when we finish the current outer spiral and move inside
            row_shift = 0
            col_shift = 1
            left_bound += 1
            right_bound -= 1

        row += row_shift
        col += col_shift
        count += 1
    return flatten
```
